'''
O      M            LITE
 bject  apper for SQ     - an experiment

the R from ORM is intentionally missing, R is support for relations.

Restrictions by design:

- single database
- maps class to table, table row to object isinstances
- relations are *NOT* supported, only single objects
- the name of the primary key is *id*.
- no query language - SQL has one already
'''

import contextlib
import functools
import sqlite3
import uuid


__all__ = (
    'connect', 'connection', 'execute_sql'
    'Model', 'UUIDModel', 'Field',
    'enable_foreign_keys', 'disable_foreign_keys',
    'transaction',
)

connection = None


def pragma_foreign_keys(extra=''):
    return connection.execute('PRAGMA foreign_keys{}'.format(extra)).fetchone()

enable_foreign_keys = functools.partial(pragma_foreign_keys, '=ON')
disable_foreign_keys = functools.partial(pragma_foreign_keys, '=OFF')

AUTOCOMMIT = None


def connect(db):
    global connection
    connection = sqlite3.connect(db)
    connection.isolation_level = AUTOCOMMIT
    enable_foreign_keys()


# TODO: BaseModel.__init__(**field_values)
# TODO: BaseModel.create()
# TODO: create_table(*Model)
# TODO: python3 support
# FIXME: CRUD operations must be executable only inside transactions!


def get_cursor(sql, params):
    '''
    with get_cursor('INSERT ... ?', ['1', ...]) as c:
        # work with cursor c
    '''
    cursor = connection.cursor()
    try:
        cursor.execute(sql, params)
        return contextlib.closing(cursor)
    except:
        cursor.close()
        raise


def execute_sql(sql, params):
    with get_cursor(sql, params):
        pass


class Field(object):

    def __init__(self, type=None):
        self.type = type


PK_FIELD = 'id'


class ModelMeta(type):

    DB_ATTRS = '__db_attrs'

    def __new__(meta, name, bases, attrs):
        cls = type.__new__(meta, name, bases, attrs)
        # set __db_attrs to be all of the Field()-s
        db_attrs = [PK_FIELD]

        for base_cls in bases:
            db_attrs.extend(
                attr
                for attr in getattr(base_cls, meta.DB_ATTRS, ())
                if attr not in db_attrs)

        db_attrs.extend(
            attr
            for attr, attr_value in attrs.items()
            if attr not in db_attrs and isinstance(attr_value, Field))

        setattr(cls, meta.DB_ATTRS, db_attrs)
        return cls


class Mapper(object):

    def __init__(self, id_generator):
        self.id_generator = id_generator
        self.object = None
        self.db_attrs = ()
        self.modified_db_attrs = set()

    def connect(self, object):
        self.object = object
        self.db_attrs = getattr(object, ModelMeta.DB_ATTRS)
        # initialize attributes
        for attr in self.db_attrs:
            setattr(object, attr, None)
        self.mark_clean()

    def mark_clean(self):
        self.modified_db_attrs.clear()

    def managed_attr_changed(self, attr):
        if attr in self.db_attrs:
            self.modified_db_attrs.add(attr)

    def save(self):
        if self.object.id is None:
            self.create()
        elif self.modified_db_attrs:
            self.update()

    def create(self):
        object = self.object
        self.generate_id()
        sql = 'INSERT INTO {table}({fields}) VALUES ({values})'.format(
            table=object.get_sqlite3_table_name(),
            fields=', '.join(self.modified_db_attrs),
            values=', '.join(['?'] * len(self.modified_db_attrs)))
        values = [getattr(object, attr) for attr in self.modified_db_attrs]
        with get_cursor(sql, values) as cursor:
            self.save_generated_id(cursor)
        self.mark_clean()

    def generate_id(self):
        if self.id_generator:
            self.object.id = self.id_generator()
        # else: id is autogenerated on database side - nothing to do

    def save_generated_id(self, cursor):
        if self.id_generator is None:
            # save database generated rowid
            self.object.id = cursor.lastrowid
        # else: self generated id is already on the object

    def update(self):
        assert PK_FIELD not in self.modified_db_attrs
        object = self.object
        fields = ['{} = ?'.format(attr) for attr in self.modified_db_attrs]
        values = [getattr(object, attr) for attr in self.modified_db_attrs]
        pk_value = object.id

        sql = 'UPDATE {table} SET {fields} WHERE id=?'.format(
            table=object.get_sqlite3_table_name(),
            fields=', '.join(fields))

        execute_sql(sql, values + [pk_value])
        self.mark_clean()

    def delete(self):
        object = self.object
        sql = 'DELETE FROM {table} WHERE id=?'.format(
            table=object.get_sqlite3_table_name())
        execute_sql(sql, [object.id])
        object.id = None
        # mark all non-pk attributes modified for re-save
        self.modified_db_attrs.update(
            attr
            for attr in self.db_attrs
            if getattr(object, attr) is not None)


def _read_row(row_class, cursor):
    row = next(cursor)
    obj = row_class()
    for idx, col in enumerate(cursor.description):
        dbattr = col[0]
        field = getattr(row_class, dbattr)
        assert isinstance(field, Field)
        # TODO: convert value as specified by Field
        setattr(obj, dbattr, row[idx])
    obj.mark_db_attributes_clean()
    return obj


class BaseModel(object):

    id_generator = None

    def __init__(self):
        self.__object_mapper = Mapper(self.id_generator)
        self.__object_mapper.connect(self)

    def __setattr__(self, name, value):
        super(BaseModel, self).__setattr__(name, value)
        self.__object_mapper.managed_attr_changed(name)

    def mark_db_attributes_clean(self):
        self.__object_mapper.mark_clean()

    @classmethod
    def get_sqlite3_table_name(cls):
        return getattr(cls, 'sqlite3_table_name', cls.__name__.lower())

    def save(self):
        self.__object_mapper.save()

    @classmethod
    def select(cls, sql_predicate, *params):
        sql = 'SELECT * FROM {table} WHERE {predicate}'.format(
            table=cls.get_sqlite3_table_name(), predicate=sql_predicate)
        with get_cursor(sql, params) as cursor:
            while True:
                yield _read_row(cls, cursor)

    @classmethod
    def by_id(cls, id):
        return list(cls.select('id=?', id))[0]

    def delete(self):
        self.__object_mapper.delete()


class Model(BaseModel):

    __metaclass__ = ModelMeta

    # primary key managed by omlite
    id = Field('INTEGER PRIMARY KEY')


class UUIDModel(BaseModel):

    ''' A Model whose id's are uuid-s.
    '''

    __metaclass__ = ModelMeta

    # primary key managed by omlite
    id = Field('VARCHAR PRIMARY KEY')

    def id_generator(self):
        ''' Generates a UUID as string.

        This one generates UUID1, override in a derived class to use
        a different UUID generator.
        '''
        return str(uuid.uuid1())


# Transactions
_transactions = 0


@contextlib.contextmanager
def transaction():
    global _transactions
    assert _transactions >= 0

    # transactions work only when the connection is in autocommit mode
    # https://pysqlite.readthedocs.org/en/latest/sqlite3.html#controlling-transactions
    # https://github.com/ghaering/pysqlite/issues/24
    # https://groups.google.com/forum/#!msg/sqlalchemy-devel/0lanNjxSpb0/6zriniGAfu0J
    # http://bugs.python.org/issue10740
    # http://rogerbinns.github.io/apsw/pysqlite.html#pysqlitediffs
    assert connection.isolation_level is AUTOCOMMIT

    savepoint_name = 'omlite_{}'.format(_transactions)
    connection.execute('SAVEPOINT {}'.format(savepoint_name))
    try:
        _transactions += 1
        yield
        connection.execute('RELEASE SAVEPOINT {}'.format(savepoint_name))
    except:
        connection.execute('ROLLBACK TO SAVEPOINT {}'.format(savepoint_name))
        raise
    finally:
        _transactions -= 1
